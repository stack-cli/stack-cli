list:
    just --list

db-migrate:
    #!/usr/bin/env bash
    set -euo pipefail

    manifest="../../infra-as-code/demo.stack.yaml"
    echo "Resolving MIGRATIONS_URL from stack secrets using ${manifest}..."

    migrations_url="$({
      stack secrets \
        --manifest "${manifest}" \
        --db-host host.docker.internal \
        --db-port 30011 \
      | sed -n 's/^MIGRATIONS_URL=//p' \
      | head -n1
    })"

    if [[ -z "${migrations_url}" ]]; then
      echo "Failed to resolve MIGRATIONS_URL from stack secrets output" >&2
      exit 1
    fi

    shopt -s nullglob
    files=(sql/migrations/*.sql)
    if [[ ${#files[@]} -eq 0 ]]; then
      echo "No migration files found in sql/migrations" >&2
      exit 1
    fi

    for file in "${files[@]}"; do
      echo "Applying ${file}..."
      LC_ALL=C psql "${migrations_url}" -v ON_ERROR_STOP=1 -f "${file}"
    done

    echo "Restarting PostgREST deployment (namespace: stack-demo)..."
    kubectl -n stack-demo rollout restart deployment/rest
    kubectl -n stack-demo rollout status deployment/rest --timeout=120s

    echo "Done."

sync-env-jwts:
    #!/usr/bin/env bash
    set -euo pipefail

    manifest="../../infra-as-code/demo.stack.yaml"
    env_file=".env.local"

    echo "Resolving JWTs from stack secrets using ${manifest}..."
    secrets_output="$({
      stack secrets \
        --manifest "${manifest}" \
        --db-host host.docker.internal \
        --db-port 30011
    })"

    anon_jwt="$(printf '%s\n' "${secrets_output}" | sed -n 's/^ANON_JWT=//p' | head -n1)"
    service_role_jwt="$(printf '%s\n' "${secrets_output}" | sed -n 's/^SERVICE_ROLE_JWT=//p' | head -n1)"

    if [[ -z "${anon_jwt}" || -z "${service_role_jwt}" ]]; then
      echo "Failed to resolve ANON_JWT or SERVICE_ROLE_JWT from stack secrets output" >&2
      exit 1
    fi

    if [[ ! -f "${env_file}" ]]; then
      printf '%s\n' \
        'SUPABASE_SERVER_URL=http://host.docker.internal:30010' \
        'NEXT_PUBLIC_SUPABASE_URL=http://localhost:30010' \
        'NEXT_PUBLIC_SUPABASE_ANON_KEY=' \
        'SUPABASE_SERVICE_ROLE_KEY=' \
        > "${env_file}"
    fi

    tmp_file="$(mktemp)"
    awk '
      BEGIN {
        saw_anon = 0
        saw_service = 0
      }
      /^NEXT_PUBLIC_SUPABASE_ANON_KEY=/ {
        print "NEXT_PUBLIC_SUPABASE_ANON_KEY=" anon
        saw_anon = 1
        next
      }
      /^SUPABASE_SERVICE_ROLE_KEY=/ {
        print "SUPABASE_SERVICE_ROLE_KEY=" service
        saw_service = 1
        next
      }
      { print }
      END {
        if (!saw_anon) print "NEXT_PUBLIC_SUPABASE_ANON_KEY=" anon
        if (!saw_service) print "SUPABASE_SERVICE_ROLE_KEY=" service
      }
    ' anon="${anon_jwt}" service="${service_role_jwt}" "${env_file}" > "${tmp_file}"

    mv "${tmp_file}" "${env_file}"
    echo "Updated ${env_file}: NEXT_PUBLIC_SUPABASE_ANON_KEY and SUPABASE_SERVICE_ROLE_KEY"

broadcast-curl message='hello from just':
    #!/usr/bin/env bash
    set -euo pipefail

    env_file=".env.local"
    if [[ ! -f "${env_file}" ]]; then
      echo "${env_file} not found. Run: just sync-env-jwts" >&2
      exit 1
    fi

    base_url="$(sed -n 's/^SUPABASE_SERVER_URL=//p' "${env_file}" | head -n1)"
    service_key="$(sed -n 's/^SUPABASE_SERVICE_ROLE_KEY=//p' "${env_file}" | head -n1)"

    if [[ -z "${base_url}" || -z "${service_key}" ]]; then
      echo "Missing SUPABASE_SERVER_URL or SUPABASE_SERVICE_ROLE_KEY in ${env_file}" >&2
      echo "Run: just sync-env-jwts" >&2
      exit 1
    fi

    msg='{{message}}'
    payload="$(printf '{"messages":[{"topic":"realtime-broadcast-demo","event":"message","payload":{"message":"%s","sent_at":"%s"},"private":false}]}' "${msg}" "$(date -u +%Y-%m-%dT%H:%M:%SZ)")"

    curl -i -sS -X POST "${base_url}/realtime/v1/api/broadcast" \
      -H "Content-Type: application/json" \
      -H "apikey: ${service_key}" \
      -H "Authorization: Bearer ${service_key}" \
      -d "${payload}"

broadcast-command cmd='kubectl get pods -A -o wide':
    #!/usr/bin/env bash
    set -euo pipefail

    env_file=".env.local"
    if [[ ! -f "${env_file}" ]]; then
      echo "${env_file} not found. Run: just sync-env-jwts" >&2
      exit 1
    fi

    base_url="$(sed -n 's/^SUPABASE_SERVER_URL=//p' "${env_file}" | head -n1)"
    service_key="$(sed -n 's/^SUPABASE_SERVICE_ROLE_KEY=//p' "${env_file}" | head -n1)"

    if [[ -z "${base_url}" || -z "${service_key}" ]]; then
      echo "Missing SUPABASE_SERVER_URL or SUPABASE_SERVICE_ROLE_KEY in ${env_file}" >&2
      echo "Run: just sync-env-jwts" >&2
      exit 1
    fi

    run_cmd='{{cmd}}'
    echo "Running and broadcasting: ${run_cmd}"

    line_no=0
    set +e
    while IFS= read -r raw_line; do
      line_no=$((line_no + 1))
      ts="$(date -u +%H:%M:%S)"
      line="${raw_line:0:500}"
      msg="[${ts}] #${line_no} ${line}"
      payload="$(printf '{"messages":[{"topic":"realtime-broadcast-demo","event":"message","payload":{"message":"%s","sent_at":"%s"},"private":false}]}' "${msg}" "$(date -u +%Y-%m-%dT%H:%M:%SZ)")"

      curl -sS -X POST "${base_url}/realtime/v1/api/broadcast" \
        -H "Content-Type: application/json" \
        -H "apikey: ${service_key}" \
        -H "Authorization: Bearer ${service_key}" \
        -d "${payload}" >/dev/null
      sleep 0.05
    done < <(bash -lc "${run_cmd}" 2>&1)
    cmd_exit=$?
    set -e

    summary="$(printf '{"messages":[{"topic":"realtime-broadcast-demo","event":"message","payload":{"message":"[done] command exit=%s","sent_at":"%s"},"private":false}]}' "${cmd_exit}" "$(date -u +%Y-%m-%dT%H:%M:%SZ)")"
    curl -sS -X POST "${base_url}/realtime/v1/api/broadcast" \
      -H "Content-Type: application/json" \
      -H "apikey: ${service_key}" \
      -H "Authorization: Bearer ${service_key}" \
      -d "${summary}" >/dev/null

    exit "${cmd_exit}"
